
    navController.addOnDestinationChangedListener((controller, destination, arguments) -> {
        Log.i(TAG, "addOnDestinationChangedListener: ");
    });


    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        //...

        appBarConfiguration = (new AppBarConfiguration.Builder(navController.getGraph())).build();

        //toolbar ??
        NavigationUI.setupWithNavController(toolbar, navController, appBarConfiguration);

        //actionBar - OptionsMenu
        NavigationUI.setupActionBarWithNavController(this, navController, appBarConfiguration);

        // CollapsingToolbar
        CollapsingToolbarLayout layout = findViewById(R.id.collapsing_toolbar_layout);
        NavigationUI.setupWithNavController(layout, toolbar, navController, appBarConfiguration);
    }

    @Override
    public boolean onOptionsItemSelected(MenuItem item) {
        switch (item.getItemId()) {
            case android.R.id.home:
                drawer.openDrawer(GravityCompat.START);
                return true;
        }
        //for BottomNavigationView ?? - как поведёт при динамическом bottom menu
        navController.popBackStack();

        // for OptionsMenu
        //NavigationUI.onNavDestinationSelected(item, navController);

        return super.onOptionsItemSelected(item);
    }


Боттом меню должны соответствовать блокам фрагментов, у которых должна быть только одно точка входа.
Эта точка входа-фрагмент должна иметь первую позицию в боттом меню, чтобы при инфлейте боттом меню при
входе в блок фрагментов активировалось первое меню. Нельзя входить во второе или третье меню фрагмет из
других блоков-фрагментов. Напр. из юзер-юлока вход в артист-блок только через фрагмент артист-релизы,
которому будет соответстовать первое меню в бооттоме - релизы. Нельзя будет войти в в артист-инфо или
артист-рейтинги из юзер-блока. И наоборот, вход в юзер-блок только через меню-фрагмент юзер-профиль.

Как синхронизировать такое поведение между боттом-меню и дровером? В дровере как правило доступен широкий
список меню блоков, напр. когда мы в артист-блоке, то можем из дровера перейти в лобое подменю юзер-блока,
но в боттом меню активным будет становиться только первое меню, что будет вводить в заблуждение о соответствии
фрагмента и активного боттом меню.

При нажатии кнопки назад после при использовании боттом меню происходит возврат на на стартовый destination.
Это плохо если мы не находимся в стартовом боттом меню. Надо решать эту проблему! Попробовать вложенные графы для
блков-фрагментом боттом меню/

Дровер не видит вложенные графы, только тот в пределах которого находится экран. Чтобы сделать переход с дровера в
вложенные графы надо писать переходы самому руками? Возможно следует навигацию привязать к боттом меню, а дровер весь
обрабатывать вручную путём вызова соответсвующих менюшек боттома или наоборот?

Оптионс меню:
    Работает адекватно (аналогично дроверу), если не переходить в другой боттом-блок не в стартовое меню.
    Тогда переход идёт нормальный, но боттом меню активируется только стартовое. Такое поведение неприемлемо для
    дровера с расширенным набором переходов вглубь боттом-блоков. Но с оптионса переходить вглубь блоков - неправильно,
    это меню нельзя перегружать! Поэтому надо входить в другой боттом-блок то только через стартовое меню блока!!!
    Для всех других случаев делать ручной переход.


Дефолтное поведения дровера с установкой NavigationUI.setupWithNavController(navigationView, navController);
не позволяет расширить его засчёт собственного navigationView.setNavigationItemSelectedListener(this).
И если необходимо изменить поведение дровера, например, при нажатии на меню вызывать
дестинацию и передавать туда параметры или вызывать другую дестинацию, то вместо setupWithNavController()
надо использовать кастомный NavigationItemSelectedListener и туда перенести часть поведения из
setupWithNavController, как-бы расширить его. Смотреть реализацию в MainActivity.

Аналогично можно расширить поведение и для NavigationUI.setupWithNavController с bottomNavView.
Для изменения поведения ActionBar, напр. двойной заголовок, надо будет сделать кастомный
NavigationUI.setupActionBarWithNavController.

!!! При навигации все фрагменты создаются с нуля, не сохраняя никаких данных в бандлах и
фрагментных вьюмоделях. Поэтому если надо сохранить данные в фрагментах после пересоздания, то использовать вьюмодели
активности и отслеживать их данные. При ротации фрагменты сохраняются и для этого случая можно
использовать аргументы, бандлы или фрагментные вьюмодели! Но при ротации фрагмент сам созраняет
данные и в дополнительной помощи бандлов и фрагментных вьюмоделей не нуждается. Поэтому нет
никакого смысла в навигационных фрагментах пользоваться бандлами и фрагментными вьюмоделями.
Все данные, которые нужно сохранить в навигационном фрагменте, сохранять во вьюмодели активности!!!

!!!1.Мега-проблема!!!
    При навигации все фрагменты создаются с нуля.
    Частично проблема решается с помощью сохранения данных и состояния фрагмента в
    вьюмоделей активности. Но это обременительно писать доп. код для сохранения состояния,
    напр. скроллирования. А пейджед-ресайклером это превращается в сложный вызов.
    Но главная проблема - производительность, трата батареи и задержки отображения при
    создании новых фрагментов со старыми данными и состоянии. Это недопустимое поведение.

 !!!2.Мега-проблема!!!
    Нелогично поведение кнопки назад для боттом меню. Фактически боттом меню не сохраняют
    навигацию по дестинейшн и при нажатии боттом менюшек, бекстек сбрасывается.
    Частично решается эта проблема кастомным NavigationUI.setupWithNavController(bottomNavView, navController),
    и теперь сохраняются переходы по менюшкам в пределах меню, но если было инфлейтено меню, то весь бекстек
    сбрасывается и переход идёт на стартовую дестинацию. Но это проблема скорее моей реализации динамического
    инфлейта менюх. Сделать одно гигантское меню со скрытыми менюшками и делать видимыми те, которые соответсвуют
    дестинации? Но боттом-меню всё-равно позволяет только максимум 5 менюх вне зависимости от видимости. Поэтому
    придётся смириться с инфлейтом боттом-меню и обнулением бек-стека. Вопрос остаётся - нужно ли в бек-стеке сохранять
    переходы по менюшкам в пределах одного боттом-меню или всегда сбрасывать бек-стек при любом нажатии на боттом-меню?
    Проблема в NavigationUI.onNavDestinationSelected(menuItem, navController). Он используется во всех типах меню.
    И именно он сбрасывает бек-стеки при инфлейте менюх и при нажиме боттом. Если его убрать и реализовать кастомно
    переходы по меню через navController.navigate(menuItemId), то всё работает отлично!!!

    Убрал из NavigationUI.onNavDestinationSelected(menuItem, navController):
        if ((item.getOrder() & Menu.CATEGORY_SECONDARY) == 0) {
            builder.setPopUpTo(findStartDestination(navController.getGraph()).getId(), false);
        }
    и все заработало адекватно!!!


 !!!3.Мега-проблема!!!
    Работа с TabLayout and ViewPager - это боль.

 Выводы:
    1. Забить на навигации джет-пак и ждать выпуск с решением этих проблем. Но тогда по
    причине неиспользования навигации джет-пака навыки его владения будут теряться, отсле-
    живание обнов усложняться и в конце-концов интерес полностью пропадёт и возможно уже не
    вернусь к этой архитектуре в силу возраста. Разгребание существующего проекта с его кучей
    недоделок займёт кучу времени и сил.

    2. Попытаться портировать часть проекта на навигации джет-пак и сравнить его работу с
    существующим проектом в плане юзабилити, производительности и потребления памяти. Есть
    подозрение что по причине пересоздания фрагментов, чистка памяти будет происходить эффективнее
    и он будет жрать меньше памяти, чем существующий проект. Если это так, то переходить на
    навигации джет-пак стоит. И впоследствии с обновлением джет-пака легче будет к нему адаптироваться.



----------- TabLayout and ViewPager --------------
ViewPagerFragment - дестинация с параметром - id таба. Тогда навигация в фрагмент таба - это
навигация в ViewPagerFragment с параметром id таба. Навигация из таба только через ViewPagerFragment.
Создавать обший SharedLiveDataSingleEvent таба с ViewPagerFragment. И передавать id дестинации из таба в
ViewPagerFragment, который отслеживает её и автоматически переанаправляет в дестинацию.
Такой подход имеет свои плюсы: т.к. табы - это не дестинации, а ViewPager-фрагменты, то они не будут
пересоздаваться при навигации по табам. Будет пересоздаваться весь ViewPagerFragment при навигации в
него, т.к. он дестинация.
Соответственно никаких вложенных в таб фрагментов быть не должно. Таб - это конечный фрагмент!
И тогда никаких вложенных в ViewPagerFragment дестинаций не будет и бек-стек по идее должен работать
адекватно.

------------------------------

FragmentNavigator extends Navigator<FragmentNavigator.Destination> {

public void navigate(@NonNull Destination destination, @Nullable Bundle args, @Nullable NavOptions navOptions) {

        // Заменить этот кусок на кусок из BaseFragmentPagerAdapter.instantiateItem()

        --->final Fragment frag = destination.createFragment(args);
        final FragmentTransaction ft = mFragmentManager.beginTransaction();

        ...

        --->ft.replace(mContainerId, frag);